// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.11.4
// source: proto/protocol.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// Client2NNClient is the client API for Client2NN service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Client2NNClient interface {
	// GET/PUT
	FileOperation(ctx context.Context, in *FileOperationArgs, opts ...grpc.CallOption) (*FileLocationResp, error)
	// 创建文件
	CreateFile(ctx context.Context, in *FileOperationArgs, opts ...grpc.CallOption) (*FileLocationResp, error)
	// 单参操作 Delete和Mkdir
	MetaOperation(ctx context.Context, in *MetaOperationArgs, opts ...grpc.CallOption) (*OperationStatus, error)
	// Rename
	RenameMeta(ctx context.Context, in *RenameArgs, opts ...grpc.CallOption) (*OperationStatus, error)
	// Stat
	GetFileMeta(ctx context.Context, in *PathArgs, opts ...grpc.CallOption) (*FileMetaInfo, error)
	// List
	GetDirMeta(ctx context.Context, in *PathArgs, opts ...grpc.CallOption) (*DirMetaList, error)
	// 数据传输完成信号
	PutComplete(ctx context.Context, in *MetaStore, opts ...grpc.CallOption) (*OperationStatus, error)
	// 更新租约
	RenewLock(ctx context.Context, in *GetLeaseArgs, opts ...grpc.CallOption) (*OperationStatus, error)
}

type client2NNClient struct {
	cc grpc.ClientConnInterface
}

func NewClient2NNClient(cc grpc.ClientConnInterface) Client2NNClient {
	return &client2NNClient{cc}
}

func (c *client2NNClient) FileOperation(ctx context.Context, in *FileOperationArgs, opts ...grpc.CallOption) (*FileLocationResp, error) {
	out := new(FileLocationResp)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/FileOperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *client2NNClient) CreateFile(ctx context.Context, in *FileOperationArgs, opts ...grpc.CallOption) (*FileLocationResp, error) {
	out := new(FileLocationResp)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/CreateFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *client2NNClient) MetaOperation(ctx context.Context, in *MetaOperationArgs, opts ...grpc.CallOption) (*OperationStatus, error) {
	out := new(OperationStatus)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/MetaOperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *client2NNClient) RenameMeta(ctx context.Context, in *RenameArgs, opts ...grpc.CallOption) (*OperationStatus, error) {
	out := new(OperationStatus)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/RenameMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *client2NNClient) GetFileMeta(ctx context.Context, in *PathArgs, opts ...grpc.CallOption) (*FileMetaInfo, error) {
	out := new(FileMetaInfo)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/GetFileMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *client2NNClient) GetDirMeta(ctx context.Context, in *PathArgs, opts ...grpc.CallOption) (*DirMetaList, error) {
	out := new(DirMetaList)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/GetDirMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *client2NNClient) PutComplete(ctx context.Context, in *MetaStore, opts ...grpc.CallOption) (*OperationStatus, error) {
	out := new(OperationStatus)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/PutComplete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *client2NNClient) RenewLock(ctx context.Context, in *GetLeaseArgs, opts ...grpc.CallOption) (*OperationStatus, error) {
	out := new(OperationStatus)
	err := c.cc.Invoke(ctx, "/proto.Client2NN/RenewLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Client2NNServer is the server API for Client2NN service.
// All implementations must embed UnimplementedClient2NNServer
// for forward compatibility
type Client2NNServer interface {
	// GET/PUT
	FileOperation(context.Context, *FileOperationArgs) (*FileLocationResp, error)
	// 创建文件
	CreateFile(context.Context, *FileOperationArgs) (*FileLocationResp, error)
	// 单参操作 Delete和Mkdir
	MetaOperation(context.Context, *MetaOperationArgs) (*OperationStatus, error)
	// Rename
	RenameMeta(context.Context, *RenameArgs) (*OperationStatus, error)
	// Stat
	GetFileMeta(context.Context, *PathArgs) (*FileMetaInfo, error)
	// List
	GetDirMeta(context.Context, *PathArgs) (*DirMetaList, error)
	// 数据传输完成信号
	PutComplete(context.Context, *MetaStore) (*OperationStatus, error)
	// 更新租约
	RenewLock(context.Context, *GetLeaseArgs) (*OperationStatus, error)
	mustEmbedUnimplementedClient2NNServer()
}

// UnimplementedClient2NNServer must be embedded to have forward compatible implementations.
type UnimplementedClient2NNServer struct {
}

func (UnimplementedClient2NNServer) FileOperation(context.Context, *FileOperationArgs) (*FileLocationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FileOperation not implemented")
}
func (UnimplementedClient2NNServer) CreateFile(context.Context, *FileOperationArgs) (*FileLocationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFile not implemented")
}
func (UnimplementedClient2NNServer) MetaOperation(context.Context, *MetaOperationArgs) (*OperationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MetaOperation not implemented")
}
func (UnimplementedClient2NNServer) RenameMeta(context.Context, *RenameArgs) (*OperationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameMeta not implemented")
}
func (UnimplementedClient2NNServer) GetFileMeta(context.Context, *PathArgs) (*FileMetaInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileMeta not implemented")
}
func (UnimplementedClient2NNServer) GetDirMeta(context.Context, *PathArgs) (*DirMetaList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDirMeta not implemented")
}
func (UnimplementedClient2NNServer) PutComplete(context.Context, *MetaStore) (*OperationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutComplete not implemented")
}
func (UnimplementedClient2NNServer) RenewLock(context.Context, *GetLeaseArgs) (*OperationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenewLock not implemented")
}
func (UnimplementedClient2NNServer) mustEmbedUnimplementedClient2NNServer() {}

// UnsafeClient2NNServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Client2NNServer will
// result in compilation errors.
type UnsafeClient2NNServer interface {
	mustEmbedUnimplementedClient2NNServer()
}

func RegisterClient2NNServer(s grpc.ServiceRegistrar, srv Client2NNServer) {
	s.RegisterService(&Client2NN_ServiceDesc, srv)
}

func _Client2NN_FileOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileOperationArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).FileOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/FileOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).FileOperation(ctx, req.(*FileOperationArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client2NN_CreateFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileOperationArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).CreateFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/CreateFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).CreateFile(ctx, req.(*FileOperationArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client2NN_MetaOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetaOperationArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).MetaOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/MetaOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).MetaOperation(ctx, req.(*MetaOperationArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client2NN_RenameMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).RenameMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/RenameMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).RenameMeta(ctx, req.(*RenameArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client2NN_GetFileMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).GetFileMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/GetFileMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).GetFileMeta(ctx, req.(*PathArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client2NN_GetDirMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).GetDirMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/GetDirMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).GetDirMeta(ctx, req.(*PathArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client2NN_PutComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetaStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).PutComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/PutComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).PutComplete(ctx, req.(*MetaStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Client2NN_RenewLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeaseArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Client2NNServer).RenewLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Client2NN/RenewLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Client2NNServer).RenewLock(ctx, req.(*GetLeaseArgs))
	}
	return interceptor(ctx, in, info, handler)
}

// Client2NN_ServiceDesc is the grpc.ServiceDesc for Client2NN service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Client2NN_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Client2NN",
	HandlerType: (*Client2NNServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FileOperation",
			Handler:    _Client2NN_FileOperation_Handler,
		},
		{
			MethodName: "CreateFile",
			Handler:    _Client2NN_CreateFile_Handler,
		},
		{
			MethodName: "MetaOperation",
			Handler:    _Client2NN_MetaOperation_Handler,
		},
		{
			MethodName: "RenameMeta",
			Handler:    _Client2NN_RenameMeta_Handler,
		},
		{
			MethodName: "GetFileMeta",
			Handler:    _Client2NN_GetFileMeta_Handler,
		},
		{
			MethodName: "GetDirMeta",
			Handler:    _Client2NN_GetDirMeta_Handler,
		},
		{
			MethodName: "PutComplete",
			Handler:    _Client2NN_PutComplete_Handler,
		},
		{
			MethodName: "RenewLock",
			Handler:    _Client2NN_RenewLock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protocol.proto",
}

// Client2DNClient is the client API for Client2DN service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Client2DNClient interface {
	// 从block中读数据
	GetBlock(ctx context.Context, in *FileOperationArgs, opts ...grpc.CallOption) (Client2DN_GetBlockClient, error)
	// 向block写数据
	WriteBlock(ctx context.Context, opts ...grpc.CallOption) (Client2DN_WriteBlockClient, error)
}

type client2DNClient struct {
	cc grpc.ClientConnInterface
}

func NewClient2DNClient(cc grpc.ClientConnInterface) Client2DNClient {
	return &client2DNClient{cc}
}

func (c *client2DNClient) GetBlock(ctx context.Context, in *FileOperationArgs, opts ...grpc.CallOption) (Client2DN_GetBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &Client2DN_ServiceDesc.Streams[0], "/proto.Client2DN/GetBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &client2DNGetBlockClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Client2DN_GetBlockClient interface {
	Recv() (*File, error)
	grpc.ClientStream
}

type client2DNGetBlockClient struct {
	grpc.ClientStream
}

func (x *client2DNGetBlockClient) Recv() (*File, error) {
	m := new(File)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *client2DNClient) WriteBlock(ctx context.Context, opts ...grpc.CallOption) (Client2DN_WriteBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &Client2DN_ServiceDesc.Streams[1], "/proto.Client2DN/WriteBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &client2DNWriteBlockClient{stream}
	return x, nil
}

type Client2DN_WriteBlockClient interface {
	Send(*FileWriteStream) error
	CloseAndRecv() (*OperationStatus, error)
	grpc.ClientStream
}

type client2DNWriteBlockClient struct {
	grpc.ClientStream
}

func (x *client2DNWriteBlockClient) Send(m *FileWriteStream) error {
	return x.ClientStream.SendMsg(m)
}

func (x *client2DNWriteBlockClient) CloseAndRecv() (*OperationStatus, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OperationStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client2DNServer is the server API for Client2DN service.
// All implementations must embed UnimplementedClient2DNServer
// for forward compatibility
type Client2DNServer interface {
	// 从block中读数据
	GetBlock(*FileOperationArgs, Client2DN_GetBlockServer) error
	// 向block写数据
	WriteBlock(Client2DN_WriteBlockServer) error
	mustEmbedUnimplementedClient2DNServer()
}

// UnimplementedClient2DNServer must be embedded to have forward compatible implementations.
type UnimplementedClient2DNServer struct {
}

func (UnimplementedClient2DNServer) GetBlock(*FileOperationArgs, Client2DN_GetBlockServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedClient2DNServer) WriteBlock(Client2DN_WriteBlockServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteBlock not implemented")
}
func (UnimplementedClient2DNServer) mustEmbedUnimplementedClient2DNServer() {}

// UnsafeClient2DNServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Client2DNServer will
// result in compilation errors.
type UnsafeClient2DNServer interface {
	mustEmbedUnimplementedClient2DNServer()
}

func RegisterClient2DNServer(s grpc.ServiceRegistrar, srv Client2DNServer) {
	s.RegisterService(&Client2DN_ServiceDesc, srv)
}

func _Client2DN_GetBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileOperationArgs)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(Client2DNServer).GetBlock(m, &client2DNGetBlockServer{stream})
}

type Client2DN_GetBlockServer interface {
	Send(*File) error
	grpc.ServerStream
}

type client2DNGetBlockServer struct {
	grpc.ServerStream
}

func (x *client2DNGetBlockServer) Send(m *File) error {
	return x.ServerStream.SendMsg(m)
}

func _Client2DN_WriteBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(Client2DNServer).WriteBlock(&client2DNWriteBlockServer{stream})
}

type Client2DN_WriteBlockServer interface {
	SendAndClose(*OperationStatus) error
	Recv() (*FileWriteStream, error)
	grpc.ServerStream
}

type client2DNWriteBlockServer struct {
	grpc.ServerStream
}

func (x *client2DNWriteBlockServer) SendAndClose(m *OperationStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *client2DNWriteBlockServer) Recv() (*FileWriteStream, error) {
	m := new(FileWriteStream)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client2DN_ServiceDesc is the grpc.ServiceDesc for Client2DN service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Client2DN_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Client2DN",
	HandlerType: (*Client2DNServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetBlock",
			Handler:       _Client2DN_GetBlock_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteBlock",
			Handler:       _Client2DN_WriteBlock_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "proto/protocol.proto",
}

// NN2DNClient is the client API for NN2DN service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NN2DNClient interface {
	// 获取block的信息
	GetReport(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*BlockReplicaList, error)
}

type nN2DNClient struct {
	cc grpc.ClientConnInterface
}

func NewNN2DNClient(cc grpc.ClientConnInterface) NN2DNClient {
	return &nN2DNClient{cc}
}

func (c *nN2DNClient) GetReport(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*BlockReplicaList, error) {
	out := new(BlockReplicaList)
	err := c.cc.Invoke(ctx, "/proto.NN2DN/GetReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NN2DNServer is the server API for NN2DN service.
// All implementations must embed UnimplementedNN2DNServer
// for forward compatibility
type NN2DNServer interface {
	// 获取block的信息
	GetReport(context.Context, *Ping) (*BlockReplicaList, error)
	mustEmbedUnimplementedNN2DNServer()
}

// UnimplementedNN2DNServer must be embedded to have forward compatible implementations.
type UnimplementedNN2DNServer struct {
}

func (UnimplementedNN2DNServer) GetReport(context.Context, *Ping) (*BlockReplicaList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReport not implemented")
}
func (UnimplementedNN2DNServer) mustEmbedUnimplementedNN2DNServer() {}

// UnsafeNN2DNServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NN2DNServer will
// result in compilation errors.
type UnsafeNN2DNServer interface {
	mustEmbedUnimplementedNN2DNServer()
}

func RegisterNN2DNServer(s grpc.ServiceRegistrar, srv NN2DNServer) {
	s.RegisterService(&NN2DN_ServiceDesc, srv)
}

func _NN2DN_GetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NN2DNServer).GetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.NN2DN/GetReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NN2DNServer).GetReport(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

// NN2DN_ServiceDesc is the grpc.ServiceDesc for NN2DN service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NN2DN_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.NN2DN",
	HandlerType: (*NN2DNServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetReport",
			Handler:    _NN2DN_GetReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protocol.proto",
}

// DN2NNClient is the client API for DN2NN service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DN2NNClient interface {
	// 心跳
	HeartBeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*DatanodeOperation, error)
	// 汇报自身状态
	BlockReport(ctx context.Context, in *BlockReplicaList, opts ...grpc.CallOption) (*OperationStatus, error)
	// 注册
	Register(ctx context.Context, in *RegisterDataNodeReq, opts ...grpc.CallOption) (*OperationStatus, error)
}

type dN2NNClient struct {
	cc grpc.ClientConnInterface
}

func NewDN2NNClient(cc grpc.ClientConnInterface) DN2NNClient {
	return &dN2NNClient{cc}
}

func (c *dN2NNClient) HeartBeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*DatanodeOperation, error) {
	out := new(DatanodeOperation)
	err := c.cc.Invoke(ctx, "/proto.DN2NN/HeartBeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dN2NNClient) BlockReport(ctx context.Context, in *BlockReplicaList, opts ...grpc.CallOption) (*OperationStatus, error) {
	out := new(OperationStatus)
	err := c.cc.Invoke(ctx, "/proto.DN2NN/BlockReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dN2NNClient) Register(ctx context.Context, in *RegisterDataNodeReq, opts ...grpc.CallOption) (*OperationStatus, error) {
	out := new(OperationStatus)
	err := c.cc.Invoke(ctx, "/proto.DN2NN/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DN2NNServer is the server API for DN2NN service.
// All implementations must embed UnimplementedDN2NNServer
// for forward compatibility
type DN2NNServer interface {
	// 心跳
	HeartBeat(context.Context, *Heartbeat) (*DatanodeOperation, error)
	// 汇报自身状态
	BlockReport(context.Context, *BlockReplicaList) (*OperationStatus, error)
	// 注册
	Register(context.Context, *RegisterDataNodeReq) (*OperationStatus, error)
	mustEmbedUnimplementedDN2NNServer()
}

// UnimplementedDN2NNServer must be embedded to have forward compatible implementations.
type UnimplementedDN2NNServer struct {
}

func (UnimplementedDN2NNServer) HeartBeat(context.Context, *Heartbeat) (*DatanodeOperation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeartBeat not implemented")
}
func (UnimplementedDN2NNServer) BlockReport(context.Context, *BlockReplicaList) (*OperationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockReport not implemented")
}
func (UnimplementedDN2NNServer) Register(context.Context, *RegisterDataNodeReq) (*OperationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedDN2NNServer) mustEmbedUnimplementedDN2NNServer() {}

// UnsafeDN2NNServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DN2NNServer will
// result in compilation errors.
type UnsafeDN2NNServer interface {
	mustEmbedUnimplementedDN2NNServer()
}

func RegisterDN2NNServer(s grpc.ServiceRegistrar, srv DN2NNServer) {
	s.RegisterService(&DN2NN_ServiceDesc, srv)
}

func _DN2NN_HeartBeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Heartbeat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DN2NNServer).HeartBeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DN2NN/HeartBeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DN2NNServer).HeartBeat(ctx, req.(*Heartbeat))
	}
	return interceptor(ctx, in, info, handler)
}

func _DN2NN_BlockReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockReplicaList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DN2NNServer).BlockReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DN2NN/BlockReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DN2NNServer).BlockReport(ctx, req.(*BlockReplicaList))
	}
	return interceptor(ctx, in, info, handler)
}

func _DN2NN_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDataNodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DN2NNServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.DN2NN/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DN2NNServer).Register(ctx, req.(*RegisterDataNodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// DN2NN_ServiceDesc is the grpc.ServiceDesc for DN2NN service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DN2NN_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.DN2NN",
	HandlerType: (*DN2NNServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HeartBeat",
			Handler:    _DN2NN_HeartBeat_Handler,
		},
		{
			MethodName: "BlockReport",
			Handler:    _DN2NN_BlockReport_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _DN2NN_Register_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protocol.proto",
}
